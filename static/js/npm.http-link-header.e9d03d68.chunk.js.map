{"version":3,"sources":["../node_modules/http-link-header/lib/link.js"],"names":["_classCallCheck","_createClass","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","STATE","trim","value","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","Link","this","refs","parse","key","links","i","length","rel","push","attr","toLowerCase","link","slice","state","ref","Error","end","indexOf","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","Object","keys","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","Buffer","isBuffer","toString","encodeURIComponent","map","item","module","exports"],"mappings":"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","file":"static/js/npm.http-link-header.e9d03d68.chunk.js","sourcesContent":["'use strict';\n\nvar _classCallCheck = require(\"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/;\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g;\nvar DELIMITER_PATTERN = /[;,\"]/;\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/;\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2\n};\n\nfunction trim(value) {\n  return value.replace(WS_TRIM_PATTERN, '');\n}\n\nfunction hasWhitespace(value) {\n  return WS_CHAR_PATTERN.test(value);\n}\n\nfunction skipWhitespace(value, offset) {\n  while (hasWhitespace(value[offset])) {\n    offset++;\n  }\n\n  return offset;\n}\n\nfunction needsQuotes(value) {\n  return WS_DELIMITER_PATTERN.test(value);\n}\n\nvar Link = /*#__PURE__*/function () {\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  function Link(value) {\n    _classCallCheck(this, Link);\n\n    /** @type {Array} URI references */\n    this.refs = [];\n\n    if (value) {\n      this.parse(value);\n    }\n  }\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n\n\n  _createClass(Link, [{\n    key: \"rel\",\n    value: function rel(value) {\n      var links = [];\n\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i].rel === value) {\n          links.push(this.refs[i]);\n        }\n      }\n\n      return links;\n    }\n    /**\n     * Get refs where given attribute has a given value\n     * @param {String} attr\n     * @param {String} value\n     * @returns {Array<Object>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(attr, value) {\n      attr = attr.toLowerCase();\n      var links = [];\n\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i][attr] === value) {\n          links.push(this.refs[i]);\n        }\n      }\n\n      return links;\n    }\n  }, {\n    key: \"set\",\n    value: function set(link) {\n      this.refs.push(link);\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(attr, value) {\n      attr = attr.toLowerCase();\n\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i][attr] === value) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(value, offset) {\n      offset = offset || 0;\n      value = offset ? value.slice(offset) : value; // Trim & unfold folded lines\n\n      value = trim(value).replace(WS_FOLD_PATTERN, '');\n      var state = STATE.IDLE;\n      var length = value.length;\n      var offset = 0;\n      var ref = null;\n\n      while (offset < length) {\n        if (state === STATE.IDLE) {\n          if (hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          } else if (value[offset] === '<') {\n            var end = value.indexOf('>', offset);\n            if (end === -1) throw new Error('Expected end of URI delimiter at offset ' + offset);\n            ref = {\n              uri: value.slice(offset + 1, end)\n            };\n            this.refs.push(ref);\n            offset = end;\n            state = STATE.URI;\n          } else {\n            throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n          }\n\n          offset++;\n        } else if (state === STATE.URI) {\n          if (hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          } else if (value[offset] === ';') {\n            state = STATE.ATTR;\n            offset++;\n          } else if (value[offset] === ',') {\n            state = STATE.IDLE;\n            offset++;\n          } else {\n            throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n          }\n        } else if (state === STATE.ATTR) {\n          if (value[offset] === ';' || hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          }\n\n          var end = value.indexOf('=', offset);\n          if (end === -1) throw new Error('Expected attribute delimiter at offset ' + offset);\n          var attr = trim(value.slice(offset, end)).toLowerCase();\n          var attrValue = '';\n          offset = end + 1;\n          offset = skipWhitespace(value, offset);\n\n          if (value[offset] === '\"') {\n            offset++;\n\n            while (offset < length) {\n              if (value[offset] === '\"') {\n                offset++;\n                break;\n              }\n\n              if (value[offset] === '\\\\') {\n                offset++;\n              }\n\n              attrValue += value[offset];\n              offset++;\n            }\n          } else {\n            var end = offset + 1;\n\n            while (!DELIMITER_PATTERN.test(value[end]) && end < length) {\n              end++;\n            }\n\n            attrValue = value.slice(offset, end);\n            offset = end;\n          }\n\n          if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {// Ignore multiples of attributes which may only appear once\n          } else if (attr[attr.length - 1] === '*') {\n            ref[attr] = Link.parseExtendedValue(attrValue);\n          } else {\n            attrValue = attr === 'rel' || attr === 'type' ? attrValue.toLowerCase() : attrValue;\n\n            if (ref[attr] != null) {\n              if (Array.isArray(ref[attr])) {\n                ref[attr].push(attrValue);\n              } else {\n                ref[attr] = [ref[attr], attrValue];\n              }\n            } else {\n              ref[attr] = attrValue;\n            }\n          }\n\n          switch (value[offset]) {\n            case ',':\n              state = STATE.IDLE;\n              break;\n\n            case ';':\n              state = STATE.ATTR;\n              break;\n          }\n\n          offset++;\n        } else {\n          throw new Error('Unknown parser state \"' + state + '\"');\n        }\n      }\n\n      ref = null;\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var refs = [];\n      var link = '';\n      var ref = null;\n\n      for (var i = 0; i < this.refs.length; i++) {\n        ref = this.refs[i];\n        link = Object.keys(this.refs[i]).reduce(function (link, attr) {\n          if (attr === 'uri') return link;\n          return link + '; ' + Link.formatAttribute(attr, ref[attr]);\n        }, '<' + ref.uri + '>');\n        refs.push(link);\n      }\n\n      return refs.join(', ');\n    }\n  }]);\n\n  return Link;\n}();\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\n\n\nLink.isCompatibleEncoding = function (value) {\n  return COMPATIBLE_ENCODING_PATTERN.test(value);\n};\n\nLink.parse = function (value, offset) {\n  return new Link().parse(value, offset);\n};\n\nLink.isSingleOccurenceAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' || attr === 'title' || attr === 'title*';\n};\n\nLink.isTokenAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor';\n};\n\nLink.escapeQuotes = function (value) {\n  return value.replace(/\"/g, '\\\\\"');\n};\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\n\n\nLink.parseExtendedValue = function (value) {\n  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec(value);\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]\n  };\n};\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\n\n\nLink.formatExtendedAttribute = function (attr, data) {\n  var encoding = (data.encoding || 'utf-8').toUpperCase();\n  var language = data.language || 'en';\n  var encodedValue = '';\n\n  if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {\n    encodedValue = data.value.toString(encoding);\n  } else if (Buffer.isBuffer(data.value)) {\n    encodedValue = data.value.toString('hex').replace(/[0-9a-f]{2}/gi, '%$1');\n  } else {\n    encodedValue = encodeURIComponent(data.value);\n  }\n\n  return attr + '=' + encoding + '\\'' + language + '\\'' + encodedValue;\n};\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\n\n\nLink.formatAttribute = function (attr, value) {\n  if (Array.isArray(value)) {\n    return value.map(function (item) {\n      return Link.formatAttribute(attr, item);\n    }).join('; ');\n  }\n\n  if (attr[attr.length - 1] === '*' || typeof value !== 'string') {\n    return Link.formatExtendedAttribute(attr, value);\n  }\n\n  if (Link.isTokenAttr(attr)) {\n    value = needsQuotes(value) ? '\"' + Link.escapeQuotes(value) + '\"' : Link.escapeQuotes(value);\n  } else if (needsQuotes(value)) {\n    value = encodeURIComponent(value); // We don't need to escape <SP> <,> <;> within quotes\n\n    value = value.replace(/%20/g, ' ').replace(/%2C/g, ',').replace(/%3B/g, ';');\n    value = '\"' + value + '\"';\n  }\n\n  return attr + '=' + value;\n};\n\nmodule.exports = Link;"],"sourceRoot":""}