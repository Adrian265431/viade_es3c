{"version":3,"sources":["../node_modules/n3/src/N3Parser.js","../node_modules/n3/src/N3Writer.js","../node_modules/n3/src/N3StreamParser.js","../node_modules/n3/src/N3StreamWriter.js","../node_modules/n3/src/N3Util.js","../node_modules/n3/src/N3Lexer.js","../node_modules/n3/src/N3Store.js","../node_modules/n3/src/IRIs.js","../node_modules/n3/src/N3DataFactory.js"],"names":["blankNodePrefix","N3Parser","options","this","_contextStack","_graph","_setBase","baseIRI","factory","initDataFactory","format","match","toLowerCase","isTurtle","isTriG","isNTriples","test","isNQuads","isN3","_n3Mode","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_resolveRelativeIRI","iri","_blankNodePrefix","replace","_lexer","lexer","lineMode","n3","_explicitQuantifiers","explicitQuantifiers","key","value","fragmentPos","indexOf","substr","_base","_basePath","_baseRoot","_baseScheme","type","graph","subject","predicate","object","n3Mode","push","inverse","_inversePredicate","blankPrefix","_prefixes","_","quantified","_quantified","id","Object","create","context","pop","_subject","_predicate","_object","token","_error","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","quantifier","_resolveIRI","_namedNode","prefix","undefined","_blankNode","_variable","_saveContext","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","length","_literalValue","_completeSubjectLiteral","_literal","_readEntity","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_restoreContext","_readPredicateAfterBlank","item","list","previousList","stack","parent","next","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","literal","datatype","_completeLiteral","listItem","completed","_readCallback","inversePredicate","_readFormulaTail","_readInTopContext","_readQuadPunctuation","_prefix","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","DEFAULTGRAPH","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","contextStack","_quad","message","err","Error","line","previousToken","noop","_removeDotSegments","result","i","pathStart","segmentStart","substring","lastIndexOf","input","quadCallback","prefixCallback","self","error","quads","e","t","tokenize","every","parser","namedNode","blankNode","variable","quad","defaultGraph","rdf","first","rest","nil","r","forAll","forSome","owl","sameAs","log","implies","prototype","xsd","escape","escapeAll","escapedCharacters","SerializedTerm","_N3DataFactory$intern","apply","arguments","internal","Term","N3Writer","outputStream","_prefixRegex","write","_lists","lists","_outputStream","_endStream","end","output","chunk","encoding","done","_writeQuad","_writeQuadLine","_prefixIRIs","prefixes","addPrefixes","string","callback","equals","_write","_inDefaultGraph","_encodeIriOrBlank","_encodeObject","_encodePredicate","_prefixMatch","quadToString","map","join","termType","characterReplacer","prefixMatch","exec","language","_encodeLiteral","addQuad","prefixIRIs","hasPrefixes","IRIlist","prefixList","prefixIRI","RegExp","child","children","contents","elements","Array","_blockedWrite","singleDone","get","character","charCodeAt","toString","_Transform","N3StreamParser","_this","call","decodeStrings","_readableState","objectMode","onData","onEnd","parse","on","event","emit","uri","_transform","_flush","stream","N3StreamWriter","_writableState","writer","_writer","addPrefix","isNamedNode","term","isBlankNode","isLiteral","isVariable","isDefaultGraph","inDefaultGraph","defaultPrefixes","processPrefix","cache","local","N3DataFactory","fromCharCode","String","escapeSequence","escapeReplacements","illegalIriChars","lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","invalidRegExp","N3Lexer","_simpleApostropheString","_prefixed","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_lineMode","_comments","comments","_literalClosingPos","inputFinished","_input","outputComments","whiteSpaceMatch","comment","_line","firstChar","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_this$_parseLiteral","_parseLiteral","_this$_parseLiteral2","double","integer","decimal","toUpperCase","boolean","_syntaxError","sequence","unicode4","unicode8","escapedChar","charCode","parseInt","isNaN","replacement","opening","openingLength","closingPos","Math","max","backslashCount","raw","lines","split","issue","tokens","_tokenizeToEnd","setImmediate","_pendingBuffer","setEncoding","data","Buffer","concat","toId","fromId","N3Store","_size","_graphs","_id","_ids","_entities","_blankNodeIndex","_factory","addQuads","index0","key0","key1","key2","index1","index2","existed","name0","name1","name2","array","tmp","entityKeys","keys","value0","entity0","value1","entity1","values","l","parts","count","isString","graphs","uniqueIds","entities","graphItem","subjects","predicates","objects","freeze","ids","changed","_addToIndex","_removeFromIndex","removeQuad","remove","removeMatches","content","subjectId","predicateId","objectId","_getGraphs","graphId","_findInIndex","_read","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","getQuads","Symbol","iterator","return","_countInIndex","some","results","forSubjects","s","_uniqueEntities","_loopBy2Keys","_loopByKey1","_loopByKey0","_loop","forPredicates","p","forObjects","o","forGraphs","g","suggestedName","name","index","_this2","_ref","_ref$remove","_ref$ignoreErrors","ignoreErrors","onError","node","tails","toRemove","forEach","tailQuad","head","headPos","items","malformed","current","objectQuads","subjectQuads","unshift","removeQuads","size","graphKey","subjectKey","predicateKey","RDF","XSD","SWAP","langString","DataFactory","_blankNodeCounter","other","NamedNode","_Term","Literal","_Term2","datatypeString","atPos","ch","dtPos","BlankNode","_Term3","Variable","_Term4","DefaultGraph","_Term5","Quad","toJSON","languageOrDataType","Number","isFinite","isInteger","triple","Triple","endPos"],"mappings":"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","file":"static/js/npm.n3.f1e87d1a.chunk.js","sourcesContent":["import _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\nvar blankNodePrefix = 0; // ## Constructor\n\nvar N3Parser = /*#__PURE__*/function () {\n  function N3Parser(options) {\n    _classCallCheck(this, N3Parser);\n\n    this._contextStack = [];\n    this._graph = null; // Set the document IRI\n\n    options = options || {};\n\n    this._setBase(options.baseIRI);\n\n    options.factory && initDataFactory(this, options.factory); // Set supported features depending on the format\n\n    var format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = format === 'turtle',\n        isTriG = format === 'trig',\n        isNTriples = /triple/.test(format),\n        isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate;\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3); // Disable relative IRIs in N-Triples or N-Quads mode\n\n    if (isLineMode) this._resolveRelativeIRI = function (iri) {\n      return null;\n    };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({\n      lineMode: isLineMode,\n      n3: isN3\n    }); // Disable explicit quantifiers by default\n\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  } // ## Static class methods\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n\n\n  _createClass(N3Parser, [{\n    key: \"_setBase\",\n    // ## Private methods\n    // ### `_setBase` sets the base IRI to resolve relative IRIs\n    value: function _setBase(baseIRI) {\n      if (!baseIRI) {\n        this._base = '';\n        this._basePath = '';\n      } else {\n        // Remove fragment if present\n        var fragmentPos = baseIRI.indexOf('#');\n        if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos); // Set base IRI and its components\n\n        this._base = baseIRI;\n        this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n        baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n        this._baseRoot = baseIRI[0];\n        this._baseScheme = baseIRI[1];\n      }\n    } // ### `_saveContext` stores the current parsing context\n    // when entering a new scope (list, blank node, formula)\n\n  }, {\n    key: \"_saveContext\",\n    value: function _saveContext(type, graph, subject, predicate, object) {\n      var n3Mode = this._n3Mode;\n\n      this._contextStack.push({\n        subject: subject,\n        predicate: predicate,\n        object: object,\n        graph: graph,\n        type: type,\n        inverse: n3Mode ? this._inversePredicate : false,\n        blankPrefix: n3Mode ? this._prefixes._ : '',\n        quantified: n3Mode ? this._quantified : null\n      }); // The settings below only apply to N3 streams\n\n\n      if (n3Mode) {\n        // Every new scope resets the predicate direction\n        this._inversePredicate = false; // In N3, blank nodes are scoped to a formula\n        // (using a dot as separator, as a blank node label cannot start with it)\n\n        this._prefixes._ = this._graph ? this._graph.id.substr(2) + '.' : '.'; // Quantifiers are scoped to a formula\n\n        this._quantified = Object.create(this._quantified);\n      }\n    } // ### `_restoreContext` restores the parent context\n    // when leaving a scope (list, blank node, formula)\n\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext() {\n      var context = this._contextStack.pop(),\n          n3Mode = this._n3Mode;\n\n      this._subject = context.subject;\n      this._predicate = context.predicate;\n      this._object = context.object;\n      this._graph = context.graph; // The settings below only apply to N3 streams\n\n      if (n3Mode) {\n        this._inversePredicate = context.inverse;\n        this._prefixes._ = context.blankPrefix;\n        this._quantified = context.quantified;\n      }\n    } // ### `_readInTopContext` reads a token when in the top context\n\n  }, {\n    key: \"_readInTopContext\",\n    value: function _readInTopContext(token) {\n      switch (token.type) {\n        // If an EOF token arrives in the top context, signal that we're done\n        case 'eof':\n          if (this._graph !== null) return this._error('Unclosed graph', token);\n          delete this._prefixes._;\n          return this._callback(null, null, this._prefixes);\n        // It could be a prefix declaration\n\n        case 'PREFIX':\n          this._sparqlStyle = true;\n\n        case '@prefix':\n          return this._readPrefix;\n        // It could be a base declaration\n\n        case 'BASE':\n          this._sparqlStyle = true;\n\n        case '@base':\n          return this._readBaseIRI;\n        // It could be a graph\n\n        case '{':\n          if (this._supportsNamedGraphs) {\n            this._graph = '';\n            this._subject = null;\n            return this._readSubject;\n          }\n\n        case 'GRAPH':\n          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n        // Otherwise, the next token must be a subject\n\n        default:\n          return this._readSubject(token);\n      }\n    } // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n\n  }, {\n    key: \"_readEntity\",\n    value: function _readEntity(token, quantifier) {\n      var value;\n\n      switch (token.type) {\n        // Read a relative or absolute IRI\n        case 'IRI':\n        case 'typeIRI':\n          var iri = this._resolveIRI(token.value);\n\n          if (iri === null) return this._error('Invalid IRI', token);\n          value = this._namedNode(iri);\n          break;\n        // Read a prefixed name\n\n        case 'type':\n        case 'prefixed':\n          var prefix = this._prefixes[token.prefix];\n          if (prefix === undefined) return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n          value = this._namedNode(prefix + token.value);\n          break;\n        // Read a blank node\n\n        case 'blank':\n          value = this._blankNode(this._prefixes[token.prefix] + token.value);\n          break;\n        // Read a variable\n\n        case 'var':\n          value = this._variable(token.value.substr(1));\n          break;\n        // Everything else is not an entity\n\n        default:\n          return this._error('Expected entity but got ' + token.type, token);\n      } // In N3 mode, replace the entity if it is quantified\n\n\n      if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n      return value;\n    } // ### `_readSubject` reads a quad's subject\n\n  }, {\n    key: \"_readSubject\",\n    value: function _readSubject(token) {\n      this._predicate = null;\n\n      switch (token.type) {\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);\n\n          return this._readBlankNodeHead;\n\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n\n          this._subject = null;\n          return this._readListItem;\n\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n          this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);\n\n          return this._readSubject;\n\n        case '}':\n          // No subject; the graph in which we are reading is closed instead\n          return this._readPunctuation(token);\n\n        case '@forSome':\n          if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORSOME;\n          this._quantifier = this._blankNode;\n          return this._readQuantifierList;\n\n        case '@forAll':\n          if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORALL;\n          this._quantifier = this._variable;\n          return this._readQuantifierList;\n\n        case 'literal':\n          if (!this._n3Mode) return this._error('Unexpected literal', token);\n\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            return this._completeSubjectLiteral;\n          } else this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n          break;\n\n        default:\n          // Read the subject entity\n          if ((this._subject = this._readEntity(token)) === undefined) return; // In N3 mode, the subject might be a path\n\n          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n      } // The next token must be a predicate,\n      // or, if the subject was actually a graph IRI, a named graph\n\n\n      return this._readPredicateOrNamedGraph;\n    } // ### `_readPredicate` reads a quad's predicate\n\n  }, {\n    key: \"_readPredicate\",\n    value: function _readPredicate(token) {\n      var type = token.type;\n\n      switch (type) {\n        case 'inverse':\n          this._inversePredicate = true;\n\n        case 'abbreviation':\n          this._predicate = this.ABBREVIATIONS[token.value];\n          break;\n\n        case '.':\n        case ']':\n        case '}':\n          // Expected predicate didn't come, must have been trailing semicolon\n          if (this._predicate === null) return this._error('Unexpected ' + type, token);\n          this._subject = null;\n          return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n\n        case ';':\n          // Additional semicolons can be safely ignored\n          return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n\n        case 'blank':\n          if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n\n        default:\n          if ((this._predicate = this._readEntity(token)) === undefined) return;\n      } // The next token must be an object\n\n\n      return this._readObject;\n    } // ### `_readObject` reads a quad's object\n\n  }, {\n    key: \"_readObject\",\n    value: function _readObject(token) {\n      switch (token.type) {\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            return this._readDataTypeOrLang;\n          } // Pre-datatyped string literal (prefix stores the datatype)\n          else this._object = this._literal(token.value, this._namedNode(token.prefix));\n\n          break;\n\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());\n\n          return this._readBlankNodeHead;\n\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n\n          this._subject = null;\n          return this._readListItem;\n\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n\n          return this._readSubject;\n\n        default:\n          // Read the object entity\n          if ((this._object = this._readEntity(token)) === undefined) return; // In N3 mode, the object might be a path\n\n          if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n      }\n\n      return this._getContextEndReader();\n    } // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n\n  }, {\n    key: \"_readPredicateOrNamedGraph\",\n    value: function _readPredicateOrNamedGraph(token) {\n      return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n    } // ### `_readGraph` reads a graph\n\n  }, {\n    key: \"_readGraph\",\n    value: function _readGraph(token) {\n      if (token.type !== '{') return this._error('Expected graph but got ' + token.type, token); // The \"subject\" we read is actually the GRAPH's label\n\n      this._graph = this._subject, this._subject = null;\n      return this._readSubject;\n    } // ### `_readBlankNodeHead` reads the head of a blank node\n\n  }, {\n    key: \"_readBlankNodeHead\",\n    value: function _readBlankNodeHead(token) {\n      if (token.type === ']') {\n        this._subject = null;\n        return this._readBlankNodeTail(token);\n      } else {\n        this._predicate = null;\n        return this._readPredicate(token);\n      }\n    } // ### `_readBlankNodeTail` reads the end of a blank node\n\n  }, {\n    key: \"_readBlankNodeTail\",\n    value: function _readBlankNodeTail(token) {\n      if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node quad\n\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this blank node\n\n      var empty = this._predicate === null;\n\n      this._restoreContext(); // If the blank node was the subject, continue reading the predicate\n\n\n      if (this._object === null) // If the blank node was empty, it could be a named graph label\n        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank; // If the blank node was the object, restore previous context and read punctuation\n      else return this._getContextEndReader();\n    } // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n\n  }, {\n    key: \"_readPredicateAfterBlank\",\n    value: function _readPredicateAfterBlank(token) {\n      switch (token.type) {\n        case '.':\n        case '}':\n          // No predicate is coming if the triple is terminated here\n          this._subject = null;\n          return this._readPunctuation(token);\n\n        default:\n          return this._readPredicate(token);\n      }\n    } // ### `_readListItem` reads items from a list\n\n  }, {\n    key: \"_readListItem\",\n    value: function _readListItem(token) {\n      var item = null,\n          // The item of the list\n      list = null,\n          // The list itself\n      previousList = this._subject,\n          // The previous list that contains this list\n      stack = this._contextStack,\n          // The stack of parent contexts\n      parent = stack[stack.length - 1],\n          // The parent containing the current list\n      next = this._readListItem; // The next function to execute\n\n      switch (token.type) {\n        case '[':\n          // Stack the current list quad and start a new quad with a blank node as subject\n          this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());\n\n          next = this._readBlankNodeHead;\n          break;\n\n        case '(':\n          // Stack the current list quad and start a new list\n          this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n\n          this._subject = null;\n          break;\n\n        case ')':\n          // Closing the list; restore the parent context\n          this._restoreContext(); // If this list is contained within a parent list, return the membership quad here.\n          // This will be `<parent list element> rdf:first <this list>.`.\n\n\n          if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph); // Was this list the parent's subject?\n\n          if (this._predicate === null) {\n            // The next token is the predicate\n            next = this._readPredicate; // No list tail if this was an empty list\n\n            if (this._subject === this.RDF_NIL) return next;\n          } // The list was in the parent context's object\n          else {\n              next = this._getContextEndReader(); // No list tail if this was an empty list\n\n              if (this._object === this.RDF_NIL) return next;\n            } // Close the list by making the head nil\n\n\n          list = this.RDF_NIL;\n          break;\n\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            next = this._readListItemDataTypeOrLang;\n          } // Pre-datatyped string literal (prefix stores the datatype)\n          else {\n              item = this._literal(token.value, this._namedNode(token.prefix));\n              next = this._getContextEndReader();\n            }\n\n          break;\n\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n\n          return this._readSubject;\n\n        default:\n          if ((item = this._readEntity(token)) === undefined) return;\n      } // Create a new blank node if no item head was assigned yet\n\n\n      if (list === null) this._subject = list = this._blankNode(); // Is this the first element of the list?\n\n      if (previousList === null) {\n        // This list is either the subject or the object of its parent\n        if (parent.predicate === null) parent.subject = list;else parent.object = list;\n      } else {\n        // Continue the previous list with the current list\n        this._emit(previousList, this.RDF_REST, list, this._graph);\n      } // If an item was read, add it to the list\n\n\n      if (item !== null) {\n        // In N3 mode, the item might be a path\n        if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n          // Create a new context to add the item's path\n          this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n\n          this._subject = item, this._predicate = null; // _readPath will restore the context and output the item\n\n          return this._getPathReader(this._readListItem);\n        } // Output the item\n\n\n        this._emit(list, this.RDF_FIRST, item, this._graph);\n      }\n\n      return next;\n    } // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n\n  }, {\n    key: \"_readDataTypeOrLang\",\n    value: function _readDataTypeOrLang(token) {\n      return this._completeObjectLiteral(token, false);\n    } // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n\n  }, {\n    key: \"_readListItemDataTypeOrLang\",\n    value: function _readListItemDataTypeOrLang(token) {\n      return this._completeObjectLiteral(token, true);\n    } // ### `_completeLiteral` completes a literal with an optional datatype or language\n\n  }, {\n    key: \"_completeLiteral\",\n    value: function _completeLiteral(token) {\n      // Create a simple string literal by default\n      var literal = this._literal(this._literalValue);\n\n      switch (token.type) {\n        // Create a datatyped literal\n        case 'type':\n        case 'typeIRI':\n          var datatype = this._readEntity(token);\n\n          if (datatype === undefined) return; // No datatype means an error occurred\n\n          literal = this._literal(this._literalValue, datatype);\n          token = null;\n          break;\n        // Create a language-tagged string\n\n        case 'langcode':\n          literal = this._literal(this._literalValue, token.value);\n          token = null;\n          break;\n      }\n\n      return {\n        token: token,\n        literal: literal\n      };\n    } // Completes a literal in subject position\n\n  }, {\n    key: \"_completeSubjectLiteral\",\n    value: function _completeSubjectLiteral(token) {\n      this._subject = this._completeLiteral(token).literal;\n      return this._readPredicateOrNamedGraph;\n    } // Completes a literal in object position\n\n  }, {\n    key: \"_completeObjectLiteral\",\n    value: function _completeObjectLiteral(token, listItem) {\n      var completed = this._completeLiteral(token);\n\n      if (!completed) return;\n      this._object = completed.literal; // If this literal was part of a list, write the item\n      // (we could also check the context stack, but passing in a flag is faster)\n\n      if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph); // If the token was consumed, continue with the rest of the input\n\n      if (completed.token === null) return this._getContextEndReader(); // Otherwise, consume the token now\n      else {\n          this._readCallback = this._getContextEndReader();\n          return this._readCallback(completed.token);\n        }\n    } // ### `_readFormulaTail` reads the end of a formula\n\n  }, {\n    key: \"_readFormulaTail\",\n    value: function _readFormulaTail(token) {\n      if (token.type !== '}') return this._readPunctuation(token); // Store the last quad of the formula\n\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this formula\n\n      this._restoreContext(); // If the formula was the subject, continue reading the predicate.\n      // If the formula was the object, read punctuation.\n\n\n      return this._object === null ? this._readPredicate : this._getContextEndReader();\n    } // ### `_readPunctuation` reads punctuation between quads or quad parts\n\n  }, {\n    key: \"_readPunctuation\",\n    value: function _readPunctuation(token) {\n      var next,\n          subject = this._subject,\n          graph = this._graph,\n          inversePredicate = this._inversePredicate;\n\n      switch (token.type) {\n        // A closing brace ends a graph\n        case '}':\n          if (this._graph === null) return this._error('Unexpected graph closing', token);\n          if (this._n3Mode) return this._readFormulaTail(token);\n          this._graph = null;\n        // A dot just ends the statement, without sharing anything with the next\n\n        case '.':\n          this._subject = null;\n          next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n          if (inversePredicate) this._inversePredicate = false;\n          break;\n        // Semicolon means the subject is shared; predicate and object are different\n\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n\n        case ',':\n          next = this._readObject;\n          break;\n\n        default:\n          // An entity means this is a quad (only allowed if not already inside a graph)\n          if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n            next = this._readQuadPunctuation;\n            break;\n          }\n\n          return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n      } // A quad has been completed now, so return it\n\n\n      if (subject !== null) {\n        var predicate = this._predicate,\n            object = this._object;\n        if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);\n      }\n\n      return next;\n    } // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n\n  }, {\n    key: \"_readBlankNodePunctuation\",\n    value: function _readBlankNodePunctuation(token) {\n      var next;\n\n      switch (token.type) {\n        // Semicolon means the subject is shared; predicate and object are different\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n\n        case ',':\n          next = this._readObject;\n          break;\n\n        default:\n          return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n      } // A quad has been completed now, so return it\n\n\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n      return next;\n    } // ### `_readQuadPunctuation` reads punctuation after a quad\n\n  }, {\n    key: \"_readQuadPunctuation\",\n    value: function _readQuadPunctuation(token) {\n      if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n      return this._readInTopContext;\n    } // ### `_readPrefix` reads the prefix of a prefix declaration\n\n  }, {\n    key: \"_readPrefix\",\n    value: function _readPrefix(token) {\n      if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n      this._prefix = token.value;\n      return this._readPrefixIRI;\n    } // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n\n  }, {\n    key: \"_readPrefixIRI\",\n    value: function _readPrefixIRI(token) {\n      if (token.type !== 'IRI') return this._error('Expected IRI to follow prefix \"' + this._prefix + ':\"', token);\n\n      var prefixNode = this._readEntity(token);\n\n      this._prefixes[this._prefix] = prefixNode.value;\n\n      this._prefixCallback(this._prefix, prefixNode);\n\n      return this._readDeclarationPunctuation;\n    } // ### `_readBaseIRI` reads the IRI of a base declaration\n\n  }, {\n    key: \"_readBaseIRI\",\n    value: function _readBaseIRI(token) {\n      var iri = token.type === 'IRI' && this._resolveIRI(token.value);\n\n      if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n\n      this._setBase(iri);\n\n      return this._readDeclarationPunctuation;\n    } // ### `_readNamedGraphLabel` reads the label of a named graph\n\n  }, {\n    key: \"_readNamedGraphLabel\",\n    value: function _readNamedGraphLabel(token) {\n      switch (token.type) {\n        case 'IRI':\n        case 'blank':\n        case 'prefixed':\n          return this._readSubject(token), this._readGraph;\n\n        case '[':\n          return this._readNamedGraphBlankLabel;\n\n        default:\n          return this._error('Invalid graph label', token);\n      }\n    } // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n\n  }, {\n    key: \"_readNamedGraphBlankLabel\",\n    value: function _readNamedGraphBlankLabel(token) {\n      if (token.type !== ']') return this._error('Invalid graph label', token);\n      this._subject = this._blankNode();\n      return this._readGraph;\n    } // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n\n  }, {\n    key: \"_readDeclarationPunctuation\",\n    value: function _readDeclarationPunctuation(token) {\n      // SPARQL-style declarations don't have punctuation\n      if (this._sparqlStyle) {\n        this._sparqlStyle = false;\n        return this._readInTopContext(token);\n      }\n\n      if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n      return this._readInTopContext;\n    } // Reads a list of quantified symbols from a @forSome or @forAll statement\n\n  }, {\n    key: \"_readQuantifierList\",\n    value: function _readQuantifierList(token) {\n      var entity;\n\n      switch (token.type) {\n        case 'IRI':\n        case 'prefixed':\n          if ((entity = this._readEntity(token, true)) !== undefined) break;\n\n        default:\n          return this._error('Unexpected ' + token.type, token);\n      } // Without explicit quantifiers, map entities to a quantified entity\n\n\n      if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value); // With explicit quantifiers, output the reified quantifier\n      else {\n          // If this is the first item, start a new quantifier list\n          if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Otherwise, continue the previous list\n          else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Output the list item\n\n          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n        }\n      return this._readQuantifierPunctuation;\n    } // Reads punctuation from a @forSome or @forAll statement\n\n  }, {\n    key: \"_readQuantifierPunctuation\",\n    value: function _readQuantifierPunctuation(token) {\n      // Read more quantifiers\n      if (token.type === ',') return this._readQuantifierList; // End of the quantifier list\n      else {\n          // With explicit quantifiers, close the quantifier list\n          if (this._explicitQuantifiers) {\n            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n\n            this._subject = null;\n          } // Read a dot\n\n\n          this._readCallback = this._getContextEndReader();\n          return this._readCallback(token);\n        }\n    } // ### `_getPathReader` reads a potential path and then resumes with the given function\n\n  }, {\n    key: \"_getPathReader\",\n    value: function _getPathReader(afterPath) {\n      this._afterPath = afterPath;\n      return this._readPath;\n    } // ### `_readPath` reads a potential path\n\n  }, {\n    key: \"_readPath\",\n    value: function _readPath(token) {\n      switch (token.type) {\n        // Forward path\n        case '!':\n          return this._readForwardPath;\n        // Backward path\n\n        case '^':\n          return this._readBackwardPath;\n        // Not a path; resume reading where we left off\n\n        default:\n          var stack = this._contextStack,\n              parent = stack.length && stack[stack.length - 1]; // If we were reading a list item, we still need to output it\n\n          if (parent && parent.type === 'item') {\n            // The list item is the remaining subejct after reading the path\n            var item = this._subject; // Switch back to the context of the list\n\n            this._restoreContext(); // Output the list item\n\n\n            this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n          }\n\n          return this._afterPath(token);\n      }\n    } // ### `_readForwardPath` reads a '!' path\n\n  }, {\n    key: \"_readForwardPath\",\n    value: function _readForwardPath(token) {\n      var subject,\n          predicate,\n          object = this._blankNode(); // The next token is the predicate\n\n\n      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's object\n\n      if (this._predicate === null) subject = this._subject, this._subject = object; // If we were reading an object, replace the subject by the path's object\n      else subject = this._object, this._object = object; // Emit the path's current quad and read its next section\n\n      this._emit(subject, predicate, object, this._graph);\n\n      return this._readPath;\n    } // ### `_readBackwardPath` reads a '^' path\n\n  }, {\n    key: \"_readBackwardPath\",\n    value: function _readBackwardPath(token) {\n      var subject = this._blankNode(),\n          predicate,\n          object; // The next token is the predicate\n\n\n      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's subject\n\n      if (this._predicate === null) object = this._subject, this._subject = subject; // If we were reading an object, replace the subject by the path's subject\n      else object = this._object, this._object = subject; // Emit the path's current quad and read its next section\n\n      this._emit(subject, predicate, object, this._graph);\n\n      return this._readPath;\n    } // ### `_getContextEndReader` gets the next reader function at the end of a context\n\n  }, {\n    key: \"_getContextEndReader\",\n    value: function _getContextEndReader() {\n      var contextStack = this._contextStack;\n      if (!contextStack.length) return this._readPunctuation;\n\n      switch (contextStack[contextStack.length - 1].type) {\n        case 'blank':\n          return this._readBlankNodeTail;\n\n        case 'list':\n          return this._readListItem;\n\n        case 'formula':\n          return this._readFormulaTail;\n      }\n    } // ### `_emit` sends a quad through the callback\n\n  }, {\n    key: \"_emit\",\n    value: function _emit(subject, predicate, object, graph) {\n      this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n    } // ### `_error` emits an error message through the callback\n\n  }, {\n    key: \"_error\",\n    value: function _error(message, token) {\n      var err = new Error(message + ' on line ' + token.line + '.');\n      err.context = {\n        token: token,\n        line: token.line,\n        previousToken: this._lexer.previousToken\n      };\n\n      this._callback(err);\n\n      this._callback = noop;\n    } // ### `_resolveIRI` resolves an IRI against the base path\n\n  }, {\n    key: \"_resolveIRI\",\n    value: function _resolveIRI(iri) {\n      return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n    } // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n    // assuming that a base path has been set and that the IRI is indeed relative\n\n  }, {\n    key: \"_resolveRelativeIRI\",\n    value: function _resolveRelativeIRI(iri) {\n      // An empty relative IRI indicates the base IRI\n      if (!iri.length) return this._base; // Decide resolving strategy based in the first character\n\n      switch (iri[0]) {\n        // Resolve relative fragment IRIs against the base IRI\n        case '#':\n          return this._base + iri;\n        // Resolve relative query string IRIs by replacing the query string\n\n        case '?':\n          return this._base.replace(/(?:\\?.*)?$/, iri);\n        // Resolve root-relative IRIs at the root of the base IRI\n\n        case '/':\n          // Resolve scheme-relative IRIs to the scheme\n          return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n        // Resolve all other IRIs at the base IRI's path\n\n        default:\n          // Relative IRIs cannot contain a colon in the first path segment\n          return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);\n      }\n    } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n\n  }, {\n    key: \"_removeDotSegments\",\n    value: function _removeDotSegments(iri) {\n      // Don't modify the IRI if it does not contain any dot segments\n      if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n\n      var result = '',\n          length = iri.length,\n          i = -1,\n          pathStart = -1,\n          segmentStart = 0,\n          next = '/';\n\n      while (i < length) {\n        switch (next) {\n          // The path starts with the first slash after the authority\n          case ':':\n            if (pathStart < 0) {\n              // Skip two slashes before the authority\n              if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n                while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {\n                  i = pathStart;\n                }\n            }\n\n            break;\n          // Don't modify a query string or fragment\n\n          case '?':\n          case '#':\n            i = length;\n            break;\n          // Handle '/.' or '/..' path segments\n\n          case '/':\n            if (iri[i + 1] === '.') {\n              next = iri[++i + 1];\n\n              switch (next) {\n                // Remove a '/.' segment\n                case '/':\n                  result += iri.substring(segmentStart, i - 1);\n                  segmentStart = i + 1;\n                  break;\n                // Remove a trailing '/.' segment\n\n                case undefined:\n                case '?':\n                case '#':\n                  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n                // Remove a '/..' segment\n\n                case '.':\n                  next = iri[++i + 1];\n\n                  if (next === undefined || next === '/' || next === '?' || next === '#') {\n                    result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result\n\n                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment\n\n                    if (next !== '/') return result + '/' + iri.substr(i + 1);\n                    segmentStart = i + 1;\n                  }\n\n              }\n            }\n\n        }\n\n        next = iri[++i];\n      }\n\n      return result + iri.substring(segmentStart);\n    } // ## Public methods\n    // ### `parse` parses the N3 input and emits each parsed quad through the callback\n\n  }, {\n    key: \"parse\",\n    value: function parse(input, quadCallback, prefixCallback) {\n      var self = this; // The read callback is the next function to be executed when a token arrives.\n      // We start reading in the top context.\n\n      this._readCallback = this._readInTopContext;\n      this._sparqlStyle = false;\n      this._prefixes = Object.create(null);\n      this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : 'b' + blankNodePrefix++ + '_';\n      this._prefixCallback = prefixCallback || noop;\n      this._inversePredicate = false;\n      this._quantified = Object.create(null); // Parse synchronously if no quad callback is given\n\n      if (!quadCallback) {\n        var quads = [],\n            error;\n\n        this._callback = function (e, t) {\n          e ? error = e : t && quads.push(t);\n        };\n\n        this._lexer.tokenize(input).every(function (token) {\n          return self._readCallback = self._readCallback(token);\n        });\n\n        if (error) throw error;\n        return quads;\n      } // Parse asynchronously otherwise, executing the read callback when a token arrives\n\n\n      this._callback = quadCallback;\n\n      this._lexer.tokenize(input, function (error, token) {\n        if (error !== null) self._callback(error), self._callback = noop;else if (self._readCallback) self._readCallback = self._readCallback(token);\n      });\n    }\n  }], [{\n    key: \"_resetBlankNodePrefix\",\n    value: function _resetBlankNodePrefix() {\n      blankNodePrefix = 0;\n    }\n  }]);\n\n  return N3Parser;\n}(); // The empty function\n\n\nexport { N3Parser as default };\n\nfunction noop() {} // Initializes the parser with the given data factory\n\n\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  var namedNode = factory.namedNode;\n  parser._namedNode = namedNode;\n  parser._blankNode = factory.blankNode;\n  parser._literal = factory.literal;\n  parser._variable = factory.variable;\n  parser._quad = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph(); // Set common named nodes\n\n  parser.RDF_FIRST = namedNode(namespaces.rdf.first);\n  parser.RDF_REST = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies)\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\n\ninitDataFactory(N3Parser.prototype, N3DataFactory);","import _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport N3DataFactory from './N3DataFactory';\nvar DEFAULTGRAPH = N3DataFactory.defaultGraph();\nvar rdf = namespaces.rdf,\n    xsd = namespaces.xsd; // Characters in literals that require escaping\n\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // ## Placeholder class to represent already pretty-printed terms\n\nvar SerializedTerm = /*#__PURE__*/function (_N3DataFactory$intern) {\n  _inherits(SerializedTerm, _N3DataFactory$intern);\n\n  function SerializedTerm() {\n    _classCallCheck(this, SerializedTerm);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SerializedTerm).apply(this, arguments));\n  }\n\n  _createClass(SerializedTerm, [{\n    key: \"equals\",\n    // Pretty-printed nodes are not equal to any other node\n    // (e.g., [] does not equal [])\n    value: function equals() {\n      return false;\n    }\n  }]);\n\n  return SerializedTerm;\n}(N3DataFactory.internal.Term); // ## Constructor\n\n\nvar N3Writer = /*#__PURE__*/function () {\n  function N3Writer(outputStream, options) {\n    _classCallCheck(this, N3Writer);\n\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/; // Shift arguments if the first argument is not a stream\n\n    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists; // If no output stream given, send the output as string through the end callback\n\n    if (!outputStream) {\n      var output = '';\n      this._outputStream = {\n        write: function write(chunk, encoding, done) {\n          output += chunk;\n          done && done();\n        },\n        end: function end(done) {\n          done && done(null, output);\n        }\n      };\n      this._endStream = true;\n    } else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    } // Initialize writer, depending on the format\n\n\n    this._subject = null;\n\n    if (!/triple|quad/i.test(options.format)) {\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n    } else {\n      this._writeQuad = this._writeQuadLine;\n    }\n  } // ## Private methods\n  // ### Whether the current graph is the default graph\n\n\n  _createClass(N3Writer, [{\n    key: \"_write\",\n    // ### `_write` writes the argument to the output stream\n    value: function _write(string, callback) {\n      this._outputStream.write(string, 'utf8', callback);\n    } // ### `_writeQuad` writes the quad to the output stream\n\n  }, {\n    key: \"_writeQuad\",\n    value: function _writeQuad(subject, predicate, object, graph, done) {\n      try {\n        // Write the graph's label if it has changed\n        if (!graph.equals(this._graph)) {\n          // Close the previous graph and start the new one\n          this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\\n' : '\\n}\\n') + (DEFAULTGRAPH.equals(graph) ? '' : this._encodeIriOrBlank(graph) + ' {\\n'));\n\n          this._graph = graph;\n          this._subject = null;\n        } // Don't repeat the subject if it's the same\n\n\n        if (subject.equals(this._subject)) {\n          // Don't repeat the predicate if it's the same\n          if (predicate.equals(this._predicate)) this._write(', ' + this._encodeObject(object), done); // Same subject, different predicate\n          else this._write(';\\n    ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);\n        } // Different subject; write the whole quad\n        else this._write((this._subject === null ? '' : '.\\n') + this._encodeIriOrBlank(this._subject = subject) + ' ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);\n      } catch (error) {\n        done && done(error);\n      }\n    } // ### `_writeQuadLine` writes the quad to the output stream as a single line\n\n  }, {\n    key: \"_writeQuadLine\",\n    value: function _writeQuadLine(subject, predicate, object, graph, done) {\n      // Write the quad without prefixes\n      delete this._prefixMatch;\n\n      this._write(this.quadToString(subject, predicate, object, graph), done);\n    } // ### `quadToString` serializes a quad as a string\n\n  }, {\n    key: \"quadToString\",\n    value: function quadToString(subject, predicate, object, graph) {\n      return this._encodeIriOrBlank(subject) + ' ' + this._encodeIriOrBlank(predicate) + ' ' + this._encodeObject(object) + (graph && graph.value ? ' ' + this._encodeIriOrBlank(graph) + ' .\\n' : ' .\\n');\n    } // ### `quadsToString` serializes an array of quads as a string\n\n  }, {\n    key: \"quadsToString\",\n    value: function quadsToString(quads) {\n      return quads.map(function (t) {\n        return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n      }, this).join('');\n    } // ### `_encodeIriOrBlank` represents an IRI or blank node\n\n  }, {\n    key: \"_encodeIriOrBlank\",\n    value: function _encodeIriOrBlank(entity) {\n      // A blank node or list is represented as-is\n      if (entity.termType !== 'NamedNode') {\n        // If it is a list head, pretty-print it\n        if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);\n        return 'id' in entity ? entity.id : '_:' + entity.value;\n      } // Escape special characters\n\n\n      var iri = entity.value;\n      if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name\n\n      var prefixMatch = this._prefixRegex.exec(iri);\n\n      return !prefixMatch ? '<' + iri + '>' : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n    } // ### `_encodeLiteral` represents a literal\n\n  }, {\n    key: \"_encodeLiteral\",\n    value: function _encodeLiteral(literal) {\n      // Escape special characters\n      var value = literal.value;\n      if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write the literal, possibly with type or language\n\n      if (literal.language) return '\"' + value + '\"@' + literal.language;else if (literal.datatype.value !== xsd.string) return '\"' + value + '\"^^' + this._encodeIriOrBlank(literal.datatype);else return '\"' + value + '\"';\n    } // ### `_encodePredicate` represents a predicate\n\n  }, {\n    key: \"_encodePredicate\",\n    value: function _encodePredicate(predicate) {\n      return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n    } // ### `_encodeObject` represents an object\n\n  }, {\n    key: \"_encodeObject\",\n    value: function _encodeObject(object) {\n      return object.termType === 'Literal' ? this._encodeLiteral(object) : this._encodeIriOrBlank(object);\n    } // ### `_blockedWrite` replaces `_write` after the writer has been closed\n\n  }, {\n    key: \"_blockedWrite\",\n    value: function _blockedWrite() {\n      throw new Error('Cannot write because the writer has been closed.');\n    } // ### `addQuad` adds the quad to the output stream\n\n  }, {\n    key: \"addQuad\",\n    value: function addQuad(subject, predicate, object, graph, done) {\n      // The quad was given as an object, so shift parameters\n      if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate); // The optional `graph` parameter was not provided\n      else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph); // The `graph` parameter was provided\n        else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n    } // ### `addQuads` adds the quads to the output stream\n\n  }, {\n    key: \"addQuads\",\n    value: function addQuads(quads) {\n      for (var i = 0; i < quads.length; i++) {\n        this.addQuad(quads[i]);\n      }\n    } // ### `addPrefix` adds the prefix to the output stream\n\n  }, {\n    key: \"addPrefix\",\n    value: function addPrefix(prefix, iri, done) {\n      var prefixes = {};\n      prefixes[prefix] = iri;\n      this.addPrefixes(prefixes, done);\n    } // ### `addPrefixes` adds the prefixes to the output stream\n\n  }, {\n    key: \"addPrefixes\",\n    value: function addPrefixes(prefixes, done) {\n      var prefixIRIs = this._prefixIRIs,\n          hasPrefixes = false;\n\n      for (var prefix in prefixes) {\n        var iri = prefixes[prefix];\n        if (typeof iri !== 'string') iri = iri.value;\n        hasPrefixes = true; // Finish a possible pending quad\n\n        if (this._subject !== null) {\n          this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n          this._subject = null, this._graph = '';\n        } // Store and write the prefix\n\n\n        prefixIRIs[iri] = prefix += ':';\n\n        this._write('@prefix ' + prefix + ' <' + iri + '>.\\n');\n      } // Recreate the prefix matcher\n\n\n      if (hasPrefixes) {\n        var IRIlist = '',\n            prefixList = '';\n\n        for (var prefixIRI in prefixIRIs) {\n          IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;\n          prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];\n        }\n\n        IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n        this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\\/]*$|' + '^(' + IRIlist + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n      } // End a prefix block with a newline\n\n\n      this._write(hasPrefixes ? '\\n' : '', done);\n    } // ### `blank` creates a blank node with the given content\n\n  }, {\n    key: \"blank\",\n    value: function blank(predicate, object) {\n      var children = predicate,\n          child,\n          length; // Empty blank node\n\n      if (predicate === undefined) children = []; // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n      else if (predicate.termType) children = [{\n          predicate: predicate,\n          object: object\n        }]; // Blank node passed as blank({ predicate: predicate, object: object })\n        else if (!('length' in predicate)) children = [predicate];\n\n      switch (length = children.length) {\n        // Generate an empty blank node\n        case 0:\n          return new SerializedTerm('[]');\n        // Generate a non-nested one-triple blank node\n\n        case 1:\n          child = children[0];\n          if (!(child.object instanceof SerializedTerm)) return new SerializedTerm('[ ' + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object) + ' ]');\n        // Generate a multi-triple or nested blank node\n\n        default:\n          var contents = '['; // Write all triples in order\n\n          for (var i = 0; i < length; i++) {\n            child = children[i]; // Write only the object is the predicate is the same as the previous\n\n            if (child.predicate.equals(predicate)) contents += ', ' + this._encodeObject(child.object); // Otherwise, write the predicate and the object\n            else {\n                contents += (i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object);\n                predicate = child.predicate;\n              }\n          }\n\n          return new SerializedTerm(contents + '\\n]');\n      }\n    } // ### `list` creates a list node with the given content\n\n  }, {\n    key: \"list\",\n    value: function list(elements) {\n      var length = elements && elements.length || 0,\n          contents = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        contents[i] = this._encodeObject(elements[i]);\n      }\n\n      return new SerializedTerm('(' + contents.join(' ') + ')');\n    } // ### `end` signals the end of the output stream\n\n  }, {\n    key: \"end\",\n    value: function end(done) {\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n        this._subject = null;\n      } // Disallow further writing\n\n\n      this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time\n\n      var singleDone = done && function (error, result) {\n        singleDone = null, done(error, result);\n      };\n\n      if (this._endStream) {\n        try {\n          return this._outputStream.end(singleDone);\n        } catch (error) {\n          /* error closing stream */\n        }\n      }\n\n      singleDone && singleDone();\n    }\n  }, {\n    key: \"_inDefaultGraph\",\n    get: function get() {\n      return DEFAULTGRAPH.equals(this._graph);\n    }\n  }]);\n\n  return N3Writer;\n}(); // Replaces a character by its escaped version\n\n\nexport { N3Writer as default };\n\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  var result = escapedCharacters[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = \"\\\\u0000\".substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n        result = \"\\\\U00000000\".substr(0, 10 - result.length) + result;\n      }\n  }\n\n  return result;\n}","import _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'stream'; // ## Constructor\n\nvar N3StreamParser = /*#__PURE__*/function (_Transform) {\n  _inherits(N3StreamParser, _Transform);\n\n  function N3StreamParser(options) {\n    var _this;\n\n    _classCallCheck(this, N3StreamParser);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(N3StreamParser).call(this, {\n      decodeStrings: true\n    }));\n    _this._readableState.objectMode = true; // Set up parser with dummy stream to obtain `data` and `end` callbacks\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this)),\n        parser = new N3Parser(options),\n        onData,\n        onEnd;\n\n    parser.parse({\n      on: function on(event, callback) {\n        switch (event) {\n          case 'data':\n            onData = callback;\n            break;\n\n          case 'end':\n            onEnd = callback;\n            break;\n        }\n      }\n    }, // Handle quads by pushing them down the pipeline\n    function (error, quad) {\n      error && self.emit('error', error) || quad && self.push(quad);\n    }, // Emit prefixes through the `prefix` event\n    function (prefix, uri) {\n      self.emit('prefix', prefix, uri);\n    }); // Implement Transform methods through parser callbacks\n\n    _this._transform = function (chunk, encoding, done) {\n      onData(chunk);\n      done();\n    };\n\n    _this._flush = function (done) {\n      onEnd();\n      done();\n    };\n\n    return _this;\n  } // ### Parses a stream of strings\n\n\n  _createClass(N3StreamParser, [{\n    key: \"import\",\n    value: function _import(stream) {\n      var self = this;\n      stream.on('data', function (chunk) {\n        self.write(chunk);\n      });\n      stream.on('end', function () {\n        self.end();\n      });\n      stream.on('error', function (error) {\n        self.emit('error', error);\n      });\n      return this;\n    }\n  }]);\n\n  return N3StreamParser;\n}(Transform);\n\nexport { N3StreamParser as default };","import _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n// **N3StreamWriter** serializes a quad stream into a text stream.\nimport { Transform } from 'stream';\nimport N3Writer from './N3Writer'; // ## Constructor\n\nvar N3StreamWriter = /*#__PURE__*/function (_Transform) {\n  _inherits(N3StreamWriter, _Transform);\n\n  function N3StreamWriter(options) {\n    var _this;\n\n    _classCallCheck(this, N3StreamWriter);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(N3StreamWriter).call(this, {\n      encoding: 'utf8'\n    }));\n    _this._writableState.objectMode = true; // Set up writer with a dummy stream object\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    var writer = _this._writer = new N3Writer({\n      write: function write(quad, encoding, callback) {\n        self.push(quad);\n        callback && callback();\n      },\n      end: function end(callback) {\n        self.push(null);\n        callback && callback();\n      }\n    }, options); // Implement Transform methods on top of writer\n\n    _this._transform = function (quad, encoding, done) {\n      writer.addQuad(quad, done);\n    };\n\n    _this._flush = function (done) {\n      writer.end(done);\n    };\n\n    return _this;\n  } // ### Serializes a stream of quads\n\n\n  _createClass(N3StreamWriter, [{\n    key: \"import\",\n    value: function _import(stream) {\n      var self = this;\n      stream.on('data', function (quad) {\n        self.write(quad);\n      });\n      stream.on('end', function () {\n        self.end();\n      });\n      stream.on('error', function (error) {\n        self.emit('error', error);\n      });\n      stream.on('prefix', function (prefix, iri) {\n        self._writer.addPrefix(prefix, iri);\n      });\n      return this;\n    }\n  }]);\n\n  return N3StreamWriter;\n}(Transform);\n\nexport { N3StreamWriter as default };","// **N3Util** provides N3 utility functions.\nimport N3DataFactory from './N3DataFactory'; // Tests whether the given term represents an IRI\n\nexport function isNamedNode(term) {\n  return !!term && term.termType === 'NamedNode';\n} // Tests whether the given term represents a blank node\n\nexport function isBlankNode(term) {\n  return !!term && term.termType === 'BlankNode';\n} // Tests whether the given term represents a literal\n\nexport function isLiteral(term) {\n  return !!term && term.termType === 'Literal';\n} // Tests whether the given term represents a variable\n\nexport function isVariable(term) {\n  return !!term && term.termType === 'Variable';\n} // Tests whether the given term represents the default graph\n\nexport function isDefaultGraph(term) {\n  return !!term && term.termType === 'DefaultGraph';\n} // Tests whether the given quad is in the default graph\n\nexport function inDefaultGraph(quad) {\n  return isDefaultGraph(quad.graph);\n} // Creates a function that prepends the given IRI to a local name\n\nexport function prefix(iri, factory) {\n  return prefixes({\n    '': iri\n  }, factory)('');\n} // Creates a function that allows registering and expanding prefixes\n\nexport function prefixes(defaultPrefixes, factory) {\n  // Add all of the default prefixes\n  var prefixes = Object.create(null);\n\n  for (var prefix in defaultPrefixes) {\n    processPrefix(prefix, defaultPrefixes[prefix]);\n  } // Set the default factory if none was specified\n\n\n  factory = factory || N3DataFactory; // Registers a new prefix (if an IRI was specified)\n  // or retrieves a function that expands an existing prefix (if no IRI was specified)\n\n  function processPrefix(prefix, iri) {\n    // Create a new prefix if an IRI is specified or the prefix doesn't exist\n    if (typeof iri === 'string') {\n      // Create a function that expands the prefix\n      var cache = Object.create(null);\n\n      prefixes[prefix] = function (local) {\n        return cache[local] || (cache[local] = factory.namedNode(iri + local));\n      };\n    } else if (!(prefix in prefixes)) {\n      throw new Error('Unknown prefix: ' + prefix);\n    }\n\n    return prefixes[prefix];\n  }\n\n  return processPrefix;\n}","import _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nvar xsd = namespaces.xsd;\nvar fromCharCode = String.fromCharCode; // Regular expression and replacement string to escape N3 strings.\n// Note how we catch invalid unicode sequences separately (they will trigger an error).\n\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\"': '\"',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'f': '\\f',\n  'b': '\\b',\n  '_': '_',\n  '~': '~',\n  '.': '.',\n  '-': '-',\n  '!': '!',\n  '$': '$',\n  '&': '&',\n  '(': '(',\n  ')': ')',\n  '*': '*',\n  '+': '+',\n  ',': ',',\n  ';': ';',\n  '=': '=',\n  '/': '/',\n  '?': '?',\n  '#': '#',\n  '@': '@',\n  '%': '%'\n};\nvar illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nvar lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true\n};\nvar invalidRegExp = /$0^/; // ## Constructor\n\nvar N3Lexer = /*#__PURE__*/function () {\n  function N3Lexer(options) {\n    _classCallCheck(this, N3Lexer);\n\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<]))/;\n    this._number = /^[\\-+]?(?:\\d+\\.?\\d*([eE](?:[\\-\\+])?\\d+)|\\d*\\.?\\d+)(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s()\\[\\]\\{\\}\"'<])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {}; // In line mode (N-Triples or N-Quads), only simple features may be parsed\n\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false; // Don't tokenize special literals\n\n      for (var key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;\n      }\n    } // When not in line mode, enable N3 functionality by default\n    else {\n        this._n3Mode = options.n3 !== false;\n      } // Don't output comment tokens by default\n\n\n    this._comments = !!options.comments; // Cache the last tested closing position of long literals\n\n    this._literalClosingPos = 0;\n  } // ## Private methods\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n\n\n  _createClass(N3Lexer, [{\n    key: \"_tokenizeToEnd\",\n    value: function _tokenizeToEnd(callback, inputFinished) {\n      // Continue parsing as far as possible; the loop will return eventually\n      var input = this._input,\n          outputComments = this._comments;\n\n      while (true) {\n        // Count and skip whitespace lines\n        var whiteSpaceMatch, comment;\n\n        while (whiteSpaceMatch = this._newline.exec(input)) {\n          // Try to find a comment\n          if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0]))) callback(null, {\n            line: this._line,\n            type: 'comment',\n            value: comment[1],\n            prefix: ''\n          }); // Advance the input\n\n          input = input.substr(whiteSpaceMatch[0].length, input.length);\n          this._line++;\n        } // Skip whitespace on current line\n\n\n        if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length); // Stop for now if we're at the end\n\n        if (this._endOfFile.test(input)) {\n          // If the input is finished, emit EOF\n          if (inputFinished) {\n            // Try to find a final comment\n            if (outputComments && (comment = this._comment.exec(input))) callback(null, {\n              line: this._line,\n              type: 'comment',\n              value: comment[1],\n              prefix: ''\n            });\n            callback(input = null, {\n              line: this._line,\n              type: 'eof',\n              value: '',\n              prefix: ''\n            });\n          }\n\n          return this._input = input;\n        } // Look for specific token types based on the first character\n\n\n        var line = this._line,\n            type = '',\n            value = '',\n            prefix = '',\n            firstChar = input[0],\n            match = null,\n            matchLength = 0,\n            inconclusive = false;\n\n        switch (firstChar) {\n          case '^':\n            // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n            if (input.length < 3) break; // Try to match a type\n            else if (input[1] === '^') {\n                this._previousMarker = '^^'; // Move to type IRI or prefixed name\n\n                input = input.substr(2);\n\n                if (input[0] !== '<') {\n                  inconclusive = true;\n                  break;\n                }\n              } // If no type, it must be a path expression\n              else {\n                  if (this._n3Mode) {\n                    matchLength = 1;\n                    type = '^';\n                  }\n\n                  break;\n                }\n          // Fall through in case the type is an IRI\n\n          case '<':\n            // Try to find a full IRI without escape sequences\n            if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1]; // Try to find a full IRI with escape sequences\n            else if (match = this._iri.exec(input)) {\n                value = this._unescape(match[1]);\n                if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);\n                type = 'IRI';\n              } // Try to find a backwards implication arrow\n              else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';\n            break;\n\n          case '_':\n            // Try to find a blank node. Since it can contain (but not end with) a dot,\n            // we always need a non-dot character before deciding it is a blank node.\n            // Therefore, try inserting a space if we're at the end of the input.\n            if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(input + ' '))) type = 'blank', prefix = '_', value = match[1];\n            break;\n\n          case '\"':\n            // Try to find a literal without escape sequences\n            if (match = this._simpleQuotedString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes\n            else {\n                var _this$_parseLiteral = this._parseLiteral(input);\n\n                value = _this$_parseLiteral.value;\n                matchLength = _this$_parseLiteral.matchLength;\n                if (value === null) return reportSyntaxError(this);\n              }\n\n            if (match !== null || matchLength !== 0) {\n              type = 'literal';\n              this._literalClosingPos = 0;\n            }\n\n            break;\n\n          case \"'\":\n            if (!this._lineMode) {\n              // Try to find a literal without escape sequences\n              if (match = this._simpleApostropheString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes\n              else {\n                  var _this$_parseLiteral2 = this._parseLiteral(input);\n\n                  value = _this$_parseLiteral2.value;\n                  matchLength = _this$_parseLiteral2.matchLength;\n                  if (value === null) return reportSyntaxError(this);\n                }\n\n              if (match !== null || matchLength !== 0) {\n                type = 'literal';\n                this._literalClosingPos = 0;\n              }\n            }\n\n            break;\n\n          case '?':\n            // Try to find a variable\n            if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];\n            break;\n\n          case '@':\n            // Try to find a language code\n            if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1]; // Try to find a keyword\n            else if (match = this._keyword.exec(input)) type = match[0];\n            break;\n\n          case '.':\n            // Try to find a dot as punctuation\n            if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n              type = '.';\n              matchLength = 1;\n              break;\n            }\n\n          // Fall through to numerical case (could be a decimal dot)\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n          case '+':\n          case '-':\n            // Try to find a number. Since it can contain (but not end with) a dot,\n            // we always need a non-dot character before deciding it is a number.\n            // Therefore, try inserting a space if we're at the end of the input.\n            if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(input + ' '))) {\n              type = 'literal', value = match[0];\n              prefix = match[1] ? xsd.double : /^[+\\-]?\\d+$/.test(match[0]) ? xsd.integer : xsd.decimal;\n            }\n\n            break;\n\n          case 'B':\n          case 'b':\n          case 'p':\n          case 'P':\n          case 'G':\n          case 'g':\n            // Try to find a SPARQL-style keyword\n            if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;\n            break;\n\n          case 'f':\n          case 't':\n            // Try to match a boolean\n            if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd.boolean;else inconclusive = true;\n            break;\n\n          case 'a':\n            // Try to find an abbreviated predicate\n            if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;\n            break;\n\n          case '=':\n            // Try to find an implication arrow or equals sign\n            if (this._n3Mode && input.length > 1) {\n              type = 'abbreviation';\n              if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';\n            }\n\n            break;\n\n          case '!':\n            if (!this._n3Mode) break;\n\n          case ',':\n          case ';':\n          case '[':\n          case ']':\n          case '(':\n          case ')':\n          case '{':\n          case '}':\n            if (!this._lineMode) {\n              matchLength = 1;\n              type = firstChar;\n            }\n\n            break;\n\n          default:\n            inconclusive = true;\n        } // Some first characters do not allow an immediate decision, so inspect more\n\n\n        if (inconclusive) {\n          // Try to find a prefix\n          if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || ''; // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a prefixed name.\n          // Therefore, try inserting a space if we're at the end of the input.\n          else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(input + ' '))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n        } // A type token is special: it can only be emitted after an IRI or prefixed name is read\n\n\n        if (this._previousMarker === '^^') {\n          switch (type) {\n            case 'prefixed':\n              type = 'type';\n              break;\n\n            case 'IRI':\n              type = 'typeIRI';\n              break;\n\n            default:\n              type = '';\n          }\n        } // What if nothing of the above was found?\n\n\n        if (!type) {\n          // We could be in streaming mode, and then we just wait for more input to arrive.\n          // Otherwise, a syntax error has occurred in the input.\n          // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n          if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);else return this._input = input;\n        } // Emit the parsed token\n\n\n        var token = {\n          line: line,\n          type: type,\n          value: value,\n          prefix: prefix\n        };\n        callback(null, token);\n        this.previousToken = token;\n        this._previousMarker = type; // Advance to next part to tokenize\n\n        input = input.substr(matchLength || match[0].length, input.length);\n      } // Signals the syntax error through the callback\n\n\n      function reportSyntaxError(self) {\n        callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n      }\n    } // ### `_unescape` replaces N3 escape codes by their corresponding characters\n\n  }, {\n    key: \"_unescape\",\n    value: function _unescape(item) {\n      try {\n        return item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {\n          var charCode;\n\n          if (unicode4) {\n            charCode = parseInt(unicode4, 16);\n            if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n            return fromCharCode(charCode);\n          } else if (unicode8) {\n            charCode = parseInt(unicode8, 16);\n            if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n            if (charCode <= 0xFFFF) return fromCharCode(charCode);\n            return fromCharCode(0xD800 + (charCode -= 0x10000) / 0x400, 0xDC00 + (charCode & 0x3FF));\n          } else {\n            var replacement = escapeReplacements[escapedChar];\n            if (!replacement) throw new Error();\n            return replacement;\n          }\n        });\n      } catch (error) {\n        return null;\n      }\n    } // ### `_parseLiteral` parses a literal into an unescaped value\n\n  }, {\n    key: \"_parseLiteral\",\n    value: function _parseLiteral(input) {\n      // Ensure we have enough lookahead to identify triple-quoted strings\n      if (input.length >= 3) {\n        // Identify the opening quote(s)\n        var opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n        var openingLength = opening.length; // Find the next candidate closing quotes\n\n        var closingPos = Math.max(this._literalClosingPos, openingLength);\n\n        while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n          // Count backslashes right before the closing quotes\n          var backslashCount = 0;\n\n          while (input[closingPos - backslashCount - 1] === '\\\\') {\n            backslashCount++;\n          } // An even number of backslashes (in particular 0)\n          // means these are actual, non-escaped closing quotes\n\n\n          if (backslashCount % 2 === 0) {\n            // Extract and unescape the value\n            var raw = input.substring(openingLength, closingPos);\n            var lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n            var matchLength = closingPos + openingLength; // Only triple-quoted strings can be multi-line\n\n            if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;\n            this._line += lines;\n            return {\n              value: this._unescape(raw),\n              matchLength: matchLength\n            };\n          }\n\n          closingPos++;\n        }\n\n        this._literalClosingPos = input.length - openingLength + 1;\n      }\n\n      return {\n        value: '',\n        matchLength: 0\n      };\n    } // ### `_syntaxError` creates a syntax error for the given issue\n\n  }, {\n    key: \"_syntaxError\",\n    value: function _syntaxError(issue) {\n      this._input = null;\n      var err = new Error('Unexpected \"' + issue + '\" on line ' + this._line + '.');\n      err.context = {\n        token: undefined,\n        line: this._line,\n        previousToken: this.previousToken\n      };\n      return err;\n    } // ## Public methods\n    // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n    // The input can be a string or a stream.\n\n  }, {\n    key: \"tokenize\",\n    value: function tokenize(input, callback) {\n      var self = this;\n      this._line = 1; // If the input is a string, continuously emit tokens through the callback until the end\n\n      if (typeof input === 'string') {\n        this._input = input; // If a callback was passed, asynchronously call it\n\n        if (typeof callback === 'function') setImmediate(function () {\n          self._tokenizeToEnd(callback, true);\n        }); // If no callback was passed, tokenize synchronously and return\n        else {\n            var tokens = [],\n                error;\n\n            this._tokenizeToEnd(function (e, t) {\n              e ? error = e : tokens.push(t);\n            }, true);\n\n            if (error) throw error;\n            return tokens;\n          }\n      } // Otherwise, the input must be a stream\n      else {\n          this._input = '';\n          this._pendingBuffer = null;\n          if (typeof input.setEncoding === 'function') input.setEncoding('utf8'); // Adds the data chunk to the buffer and parses as far as possible\n\n          input.on('data', function (data) {\n            if (self._input !== null && data.length !== 0) {\n              // Prepend any previous pending writes\n              if (self._pendingBuffer) {\n                data = Buffer.concat([self._pendingBuffer, data]);\n                self._pendingBuffer = null;\n              } // Hold if the buffer ends in an incomplete unicode sequence\n\n\n              if (data[data.length - 1] & 0x80) {\n                self._pendingBuffer = data;\n              } // Otherwise, tokenize as far as possible\n              else {\n                  self._input += data;\n\n                  self._tokenizeToEnd(callback, false);\n                }\n            }\n          }); // Parses until the end\n\n          input.on('end', function () {\n            if (self._input !== null) self._tokenizeToEnd(callback, true);\n          });\n          input.on('error', callback);\n        }\n    }\n  }]);\n\n  return N3Lexer;\n}();\n\nexport { N3Lexer as default };","import _toConsumableArray from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// **N3Store** objects store N3 quads by graph in memory.\nimport N3DataFactory from './N3DataFactory';\nimport { Readable } from 'stream';\nimport namespaces from './IRIs';\nvar _N3DataFactory$intern = N3DataFactory.internal,\n    toId = _N3DataFactory$intern.toId,\n    fromId = _N3DataFactory$intern.fromId; // ## Constructor\n\nvar N3Store = /*#__PURE__*/function () {\n  function N3Store(quads, options) {\n    _classCallCheck(this, N3Store);\n\n    // The number of quads is initially zero\n    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph\n\n    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n\n    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given\n\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory; // Add quads if passed\n\n    if (quads) this.addQuads(quads);\n  } // ## Public properties\n  // ### `size` returns the number of quads in the store\n\n\n  _createClass(N3Store, [{\n    key: \"_addToIndex\",\n    // ## Private methods\n    // ### `_addToIndex` adds a quad to a three-layered index.\n    // Returns if the index has changed, if the entry did not already exist.\n    value: function _addToIndex(index0, key0, key1, key2) {\n      // Create layers as necessary\n      var index1 = index0[key0] || (index0[key0] = {});\n      var index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad\n\n      var existed = key2 in index2;\n      if (!existed) index2[key2] = null;\n      return !existed;\n    } // ### `_removeFromIndex` removes a quad from a three-layered index\n\n  }, {\n    key: \"_removeFromIndex\",\n    value: function _removeFromIndex(index0, key0, key1, key2) {\n      // Remove the quad from the index\n      var index1 = index0[key0],\n          index2 = index1[key1],\n          key;\n      delete index2[key2]; // Remove intermediary index layers if they are empty\n\n      for (key in index2) {\n        return;\n      }\n\n      delete index1[key1];\n\n      for (key in index1) {\n        return;\n      }\n\n      delete index0[key0];\n    } // ### `_findInIndex` finds a set of quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    // `name0`, `name1`, and `name2` are the names of the keys at each level,\n    // used when reconstructing the resulting quad\n    // (for instance: _subject_, _predicate_, and _object_).\n    // Finally, `graph` will be the graph of the created quads.\n    // If `callback` is given, each result is passed through it\n    // and iteration halts when it returns truthy for any quad.\n    // If instead `array` is given, each result is added to the array.\n\n  }, {\n    key: \"_findInIndex\",\n    value: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n      var tmp,\n          index1,\n          index2,\n          varCount = !key0 + !key1 + !key2,\n          // depending on the number of variables, keys or reverse index are faster\n      entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities; // If a key is specified, use only that part of index 0.\n\n      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n      for (var value0 in index0) {\n        var entity0 = entityKeys[value0];\n\n        if (index1 = index0[value0]) {\n          // If a key is specified, use only that part of index 1.\n          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n          for (var value1 in index1) {\n            var entity1 = entityKeys[value1];\n\n            if (index2 = index1[value1]) {\n              // If a key is specified, use only that part of index 2, if it exists.\n              var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n\n              for (var l = 0; l < values.length; l++) {\n                var parts = {\n                  subject: null,\n                  predicate: null,\n                  object: null\n                };\n                parts[name0] = fromId(entity0, this._factory);\n                parts[name1] = fromId(entity1, this._factory);\n                parts[name2] = fromId(entityKeys[values[l]], this._factory);\n\n                var quad = this._factory.quad(parts.subject, parts.predicate, parts.object, fromId(graph, this._factory));\n\n                if (array) array.push(quad);else if (callback(quad)) return true;\n              }\n            }\n          }\n        }\n      }\n\n      return array;\n    } // ### `_loop` executes the callback on all keys of index 0\n\n  }, {\n    key: \"_loop\",\n    value: function _loop(index0, callback) {\n      for (var key0 in index0) {\n        callback(key0);\n      }\n    } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n\n  }, {\n    key: \"_loopByKey0\",\n    value: function _loopByKey0(index0, key0, callback) {\n      var index1, key1;\n\n      if (index1 = index0[key0]) {\n        for (key1 in index1) {\n          callback(key1);\n        }\n      }\n    } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n\n  }, {\n    key: \"_loopByKey1\",\n    value: function _loopByKey1(index0, key1, callback) {\n      var key0, index1;\n\n      for (key0 in index0) {\n        index1 = index0[key0];\n        if (index1[key1]) callback(key0);\n      }\n    } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n\n  }, {\n    key: \"_loopBy2Keys\",\n    value: function _loopBy2Keys(index0, key0, key1, callback) {\n      var index1, index2, key2;\n\n      if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n        for (key2 in index2) {\n          callback(key2);\n        }\n      }\n    } // ### `_countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n\n  }, {\n    key: \"_countInIndex\",\n    value: function _countInIndex(index0, key0, key1, key2) {\n      var count = 0,\n          tmp,\n          index1,\n          index2; // If a key is specified, count only that part of index 0\n\n      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n      for (var value0 in index0) {\n        if (index1 = index0[value0]) {\n          // If a key is specified, count only that part of index 1\n          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n          for (var value1 in index1) {\n            if (index2 = index1[value1]) {\n              // If a key is specified, count the quad if it exists\n              if (key2) key2 in index2 && count++; // Otherwise, count all quads\n              else count += Object.keys(index2).length;\n            }\n          }\n        }\n      }\n\n      return count;\n    } // ### `_getGraphs` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n\n  }, {\n    key: \"_getGraphs\",\n    value: function _getGraphs(graph) {\n      if (!isString(graph)) return this._graphs;\n      var graphs = {};\n      graphs[graph] = this._graphs[graph];\n      return graphs;\n    } // ### `_uniqueEntities` returns a function that accepts an entity ID\n    // and passes the corresponding entity to callback if it hasn't occurred before.\n\n  }, {\n    key: \"_uniqueEntities\",\n    value: function _uniqueEntities(callback) {\n      var uniqueIds = Object.create(null),\n          entities = this._entities;\n      return function (id) {\n        if (!(id in uniqueIds)) {\n          uniqueIds[id] = true;\n          callback(fromId(entities[id]));\n        }\n      };\n    } // ## Public methods\n    // ### `addQuad` adds a new quad to the store.\n    // Returns if the quad index has changed, if the quad did not already exist.\n\n  }, {\n    key: \"addQuad\",\n    value: function addQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n      subject = toId(subject);\n      predicate = toId(predicate);\n      object = toId(object);\n      graph = toId(graph); // Find the graph that will contain the triple\n\n      var graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet\n\n      if (!graphItem) {\n        graphItem = this._graphs[graph] = {\n          subjects: {},\n          predicates: {},\n          objects: {}\n        }; // Freezing a graph helps subsequent `add` performance,\n        // and properties will never be modified anyway\n\n        Object.freeze(graphItem);\n      } // Since entities can often be long IRIs, we avoid storing them in every index.\n      // Instead, we have a separate index that maps entities to numbers,\n      // which are then used as keys in the other indexes.\n\n\n      var ids = this._ids;\n      var entities = this._entities;\n      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n      object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n\n      var changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n      this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n      this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid\n\n\n      this._size = null;\n      return changed;\n    } // ### `addQuads` adds multiple quads to the store\n\n  }, {\n    key: \"addQuads\",\n    value: function addQuads(quads) {\n      for (var i = 0; i < quads.length; i++) {\n        this.addQuad(quads[i]);\n      }\n    } // ### `import` adds a stream of quads to the store\n\n  }, {\n    key: \"import\",\n    value: function _import(stream) {\n      var self = this;\n      stream.on('data', function (quad) {\n        self.addQuad(quad);\n      });\n      return stream;\n    } // ### `removeQuad` removes a quad from the store if it exists\n\n  }, {\n    key: \"removeQuad\",\n    value: function removeQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n      subject = toId(subject);\n      predicate = toId(predicate);\n      object = toId(object);\n      graph = toId(graph); // Find internal identifiers for all components\n      // and verify the quad exists.\n\n      var graphItem,\n          ids = this._ids,\n          graphs = this._graphs,\n          subjects,\n          predicates;\n      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes\n\n      this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n      this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n      this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n      if (this._size !== null) this._size--; // Remove the graph if it is empty\n\n      for (subject in graphItem.subjects) {\n        return true;\n      }\n\n      delete graphs[graph];\n      return true;\n    } // ### `removeQuads` removes multiple quads from the store\n\n  }, {\n    key: \"removeQuads\",\n    value: function removeQuads(quads) {\n      for (var i = 0; i < quads.length; i++) {\n        this.removeQuad(quads[i]);\n      }\n    } // ### `remove` removes a stream of quads from the store\n\n  }, {\n    key: \"remove\",\n    value: function remove(stream) {\n      var self = this;\n      stream.on('data', function (quad) {\n        self.removeQuad(quad);\n      });\n      return stream;\n    } // ### `removeMatches` removes all matching quads from the store\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"removeMatches\",\n    value: function removeMatches(subject, predicate, object, graph) {\n      return this.remove(this.match(subject, predicate, object, graph));\n    } // ### `deleteGraph` removes all triples with the given graph from the store\n\n  }, {\n    key: \"deleteGraph\",\n    value: function deleteGraph(graph) {\n      return this.removeMatches(null, null, null, graph);\n    } // ### `getQuads` returns an array of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getQuads\",\n    value: function getQuads(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var quads = [],\n          graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return quads;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subjectId) {\n            if (objectId) // If subject and object are given, the object index will be the fastest\n              this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);else // If only subject and possibly predicate are given, the subject index will be the fastest\n              this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n          } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest\n            this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);else if (objectId) // If only object is given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);else // If nothing is given, iterate subjects and predicates first\n            this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n        }\n      }\n\n      return quads;\n    } // ### `match` returns a stream of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      var _this = this;\n\n      var stream = new Readable({\n        objectMode: true\n      }); // Initialize stream once it is being read\n\n      stream._read = function () {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _this.getQuads(subject, predicate, object, graph)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var quad = _step.value;\n            stream.push(quad);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        stream.push(null);\n      };\n\n      return stream;\n    } // ### `countQuads` returns the number of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"countQuads\",\n    value: function countQuads(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var count = 0,\n          graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subject) {\n            if (object) // If subject and object are given, the object index will be the fastest\n              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest\n              count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n          } else if (predicate) {\n            // If only predicate and possibly object are given, the predicate index will be the fastest\n            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n          } else {\n            // If only object is possibly given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          }\n        }\n      }\n\n      return count;\n    } // ### `forEach` executes the callback on all quads.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, subject, predicate, object, graph) {\n      this.some(function (quad) {\n        callback(quad);\n        return false;\n      }, subject, predicate, object, graph);\n    } // ### `every` executes the callback on all quads,\n    // and returns `true` if it returns truthy for all them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"every\",\n    value: function every(callback, subject, predicate, object, graph) {\n      var some = false;\n      var every = !this.some(function (quad) {\n        some = true;\n        return !callback(quad);\n      }, subject, predicate, object, graph);\n      return some && every;\n    } // ### `some` executes the callback on all quads,\n    // and returns `true` if it returns truthy for any of them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"some\",\n    value: function some(callback, subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var graphs = this._getGraphs(graph),\n          content,\n          ids = this._ids,\n          subjectId,\n          predicateId,\n          objectId; // Translate IRIs to internal index keys.\n\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return false;\n\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subjectId) {\n            if (objectId) {\n              // If subject and object are given, the object index will be the fastest\n              if (this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, callback, null)) return true;\n            } else // If only subject and possibly predicate are given, the subject index will be the fastest\n              if (this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, callback, null)) return true;\n          } else if (predicateId) {\n            // If only predicate and possibly object are given, the predicate index will be the fastest\n            if (this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, callback, null)) {\n              return true;\n            }\n          } else if (objectId) {\n            // If only object is given, the object index will be the fastest\n            if (this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, callback, null)) {\n              return true;\n            }\n          } else // If nothing is given, iterate subjects and predicates first\n            if (this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, callback, null)) {\n              return true;\n            }\n        }\n      }\n\n      return false;\n    } // ### `getSubjects` returns all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getSubjects\",\n    value: function getSubjects(predicate, object, graph) {\n      var results = [];\n      this.forSubjects(function (s) {\n        results.push(s);\n      }, predicate, object, graph);\n      return results;\n    } // ### `forSubjects` executes the callback on all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forSubjects\",\n    value: function forSubjects(callback, predicate, object, graph) {\n      // Convert terms to internal string representation\n      predicate = predicate && toId(predicate);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          predicateId,\n          objectId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (predicateId) {\n            if (objectId) // If predicate and object are given, the POS index is best.\n              this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.\n              this._loopByKey1(content.subjects, predicateId, callback);\n          } else if (objectId) // If only object is given, the OSP index is best.\n            this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects\n            this._loop(content.subjects, callback);\n        }\n      }\n    } // ### `getPredicates` returns all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getPredicates\",\n    value: function getPredicates(subject, object, graph) {\n      var results = [];\n      this.forPredicates(function (p) {\n        results.push(p);\n      }, subject, object, graph);\n      return results;\n    } // ### `forPredicates` executes the callback on all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forPredicates\",\n    value: function forPredicates(callback, subject, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      object = object && toId(object);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          subjectId,\n          objectId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (objectId) // If subject and object are given, the OSP index is best.\n              this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.\n              this._loopByKey0(content.subjects, subjectId, callback);\n          } else if (objectId) // If only object is given, the POS index is best.\n            this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.\n            this._loop(content.predicates, callback);\n        }\n      }\n    } // ### `getObjects` returns all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getObjects\",\n    value: function getObjects(subject, predicate, graph) {\n      var results = [];\n      this.forObjects(function (o) {\n        results.push(o);\n      }, subject, predicate, graph);\n      return results;\n    } // ### `forObjects` executes the callback on all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forObjects\",\n    value: function forObjects(callback, subject, predicate, graph) {\n      // Convert terms to internal string representation\n      subject = subject && toId(subject);\n      predicate = predicate && toId(predicate);\n      graph = graph && toId(graph);\n\n      var ids = this._ids,\n          graphs = this._getGraphs(graph),\n          content,\n          subjectId,\n          predicateId;\n\n      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (predicateId) // If subject and predicate are given, the SPO index is best.\n              this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.\n              this._loopByKey1(content.objects, subjectId, callback);\n          } else if (predicateId) // If only predicate is given, the POS index is best.\n            this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.\n            this._loop(content.objects, callback);\n        }\n      }\n    } // ### `getGraphs` returns all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"getGraphs\",\n    value: function getGraphs(subject, predicate, object) {\n      var results = [];\n      this.forGraphs(function (g) {\n        results.push(g);\n      }, subject, predicate, object);\n      return results;\n    } // ### `forGraphs` executes the callback on all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n\n  }, {\n    key: \"forGraphs\",\n    value: function forGraphs(callback, subject, predicate, object) {\n      for (var graph in this._graphs) {\n        this.some(function (quad) {\n          callback(quad.graph);\n          return true; // Halt iteration of some()\n        }, subject, predicate, object, graph);\n      }\n    } // ### `createBlankNode` creates a new blank node, returning its name\n\n  }, {\n    key: \"createBlankNode\",\n    value: function createBlankNode(suggestedName) {\n      var name, index; // Generate a name based on the suggested name\n\n      if (suggestedName) {\n        name = suggestedName = '_:' + suggestedName, index = 1;\n\n        while (this._ids[name]) {\n          name = suggestedName + index++;\n        }\n      } // Generate a generic blank node name\n      else {\n          do {\n            name = '_:b' + this._blankNodeIndex++;\n          } while (this._ids[name]);\n        } // Add the blank node to the entities, avoiding the generation of duplicates\n\n\n      this._ids[name] = ++this._id;\n      this._entities[this._id] = name;\n      return this._factory.blankNode(name.substr(2));\n    } // ### `extractLists` finds and removes all list triples\n    // and returns the items per list.\n\n  }, {\n    key: \"extractLists\",\n    value: function extractLists() {\n      var _this2 = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$remove = _ref.remove,\n          remove = _ref$remove === void 0 ? false : _ref$remove,\n          _ref$ignoreErrors = _ref.ignoreErrors,\n          ignoreErrors = _ref$ignoreErrors === void 0 ? false : _ref$ignoreErrors;\n\n      var lists = {}; // has scalar keys so could be a simple Object\n\n      var onError = ignoreErrors ? function () {\n        return true;\n      } : function (node, message) {\n        throw new Error(\"\".concat(node.value, \" \").concat(message));\n      }; // Traverse each list from its tail\n\n      var tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n      var toRemove = remove ? _toConsumableArray(tails) : [];\n      tails.forEach(function (tailQuad) {\n        var items = []; // the members found as objects of rdf:first quads\n\n        var malformed = false; // signals whether the current list is malformed\n\n        var head; // the head of the list (_:b1 in above example)\n\n        var headPos; // set to subject or object when head is set\n\n        var graph = tailQuad.graph; // make sure list is in exactly one graph\n        // Traverse the list from tail to end\n\n        var current = tailQuad.subject;\n\n        while (current && !malformed) {\n          var objectQuads = _this2.getQuads(null, null, current, null);\n\n          var subjectQuads = _this2.getQuads(current, null, null, null);\n\n          var i,\n              quad,\n              first = null,\n              rest = null,\n              parent = null; // Find the first and rest of this list node\n\n          for (i = 0; i < subjectQuads.length && !malformed; i++) {\n            quad = subjectQuads[i];\n            if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out'); // one rdf:first\n            else if (quad.predicate.value === namespaces.rdf.first) {\n                if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);\n              } // one rdf:rest\n              else if (quad.predicate.value === namespaces.rdf.rest) {\n                  if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);\n                } // alien triple\n                else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');else {\n                    head = quad; // e.g. { (1 2 3) :p :o }\n\n                    headPos = 'subject';\n                  }\n          } // { :s :p (1 2) } arrives here with no head\n          // { (1 2) :p :o } arrives here with head set to the list.\n\n\n          for (i = 0; i < objectQuads.length && !malformed; ++i) {\n            quad = objectQuads[i];\n            if (head) malformed = onError(current, 'can\\'t have coreferences'); // one rdf:rest\n            else if (quad.predicate.value === namespaces.rdf.rest) {\n                if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;\n              } else {\n                head = quad; // e.g. { :s :p (1 2) }\n\n                headPos = 'object';\n              }\n          } // Store the list item and continue with parent\n\n\n          if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);\n          current = parent && parent.subject;\n        } // Don't remove any quads if the list is malformed\n\n\n        if (malformed) remove = false; // Store the list under the value of its head\n        else if (head) lists[head[headPos].value] = items;\n      }); // Remove list quads if requested\n\n      if (remove) this.removeQuads(toRemove);\n      return lists;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      // Return the quad count if if was cached\n      var size = this._size;\n      if (size !== null) return size; // Calculate the number of quads by counting to the deepest level\n\n      size = 0;\n      var graphs = this._graphs,\n          subjects,\n          subject;\n\n      for (var graphKey in graphs) {\n        for (var subjectKey in subjects = graphs[graphKey].subjects) {\n          for (var predicateKey in subject = subjects[subjectKey]) {\n            size += Object.keys(subject[predicateKey]).length;\n          }\n        }\n      }\n\n      return this._size = size;\n    }\n  }]);\n\n  return N3Store;\n}(); // Determines whether the argument is a string\n\n\nexport { N3Store as default };\n\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}","var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    XSD = 'http://www.w3.org/2001/XMLSchema#',\n    SWAP = 'http://www.w3.org/2000/10/swap/';\nexport default {\n  xsd: {\n    decimal: XSD + 'decimal',\n    boolean: XSD + 'boolean',\n    double: XSD + 'double',\n    integer: XSD + 'integer',\n    string: XSD + 'string'\n  },\n  rdf: {\n    type: RDF + 'type',\n    nil: RDF + 'nil',\n    first: RDF + 'first',\n    rest: RDF + 'rest',\n    langString: RDF + 'langString'\n  },\n  owl: {\n    sameAs: 'http://www.w3.org/2002/07/owl#sameAs'\n  },\n  r: {\n    forSome: SWAP + 'reify#forSome',\n    forAll: SWAP + 'reify#forAll'\n  },\n  log: {\n    implies: SWAP + 'log#implies'\n  }\n};","import _assertThisInitialized from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _possibleConstructorReturn from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/travis/build/Arquisoft/viade_es3c/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\nimport namespaces from './IRIs';\nvar rdf = namespaces.rdf,\n    xsd = namespaces.xsd;\nvar DataFactory, DEFAULTGRAPH;\nvar _blankNodeCounter = 0; // ## Term constructor\n\nvar Term = /*#__PURE__*/function () {\n  function Term(id) {\n    _classCallCheck(this, Term);\n\n    this.id = id;\n  } // ### The value of this term\n\n\n  _createClass(Term, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value\n\n      return !!other && this.termType === other.termType && this.value === other.value;\n    } // ### Returns a plain object representation of this term\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value\n      };\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id;\n    }\n  }]);\n\n  return Term;\n}(); // ## NamedNode constructor\n\n\nvar NamedNode = /*#__PURE__*/function (_Term) {\n  _inherits(NamedNode, _Term);\n\n  function NamedNode() {\n    _classCallCheck(this, NamedNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NamedNode).apply(this, arguments));\n  }\n\n  _createClass(NamedNode, [{\n    key: \"termType\",\n    // ### The term type of this term\n    get: function get() {\n      return 'NamedNode';\n    }\n  }]);\n\n  return NamedNode;\n}(Term); // ## Literal constructor\n\n\nvar Literal = /*#__PURE__*/function (_Term2) {\n  _inherits(Literal, _Term2);\n\n  function Literal() {\n    _classCallCheck(this, Literal);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Literal).apply(this, arguments));\n  }\n\n  _createClass(Literal, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both literals were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype\n\n      return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value,\n        language: this.language,\n        datatype: {\n          termType: 'NamedNode',\n          value: this.datatypeString\n        }\n      };\n    }\n  }, {\n    key: \"termType\",\n    // ### The term type of this term\n    get: function get() {\n      return 'Literal';\n    } // ### The text value of this literal\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substring(1, this.id.lastIndexOf('\"'));\n    } // ### The language of this literal\n\n  }, {\n    key: \"language\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"@en-us')\n      var id = this.id,\n          atPos = id.lastIndexOf('\"') + 1; // If \"@\" it follows, return the remaining substring; empty otherwise\n\n      return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n    } // ### The datatype IRI of this literal\n\n  }, {\n    key: \"datatype\",\n    get: function get() {\n      return new NamedNode(this.datatypeString);\n    } // ### The datatype string of this literal\n\n  }, {\n    key: \"datatypeString\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n      var id = this.id,\n          dtPos = id.lastIndexOf('\"') + 1,\n          ch; // If \"^\" it follows, return the remaining substring\n\n      return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) : // If \"@\" follows, return rdf:langString; xsd:string otherwise\n      ch !== '@' ? xsd.string : rdf.langString;\n    }\n  }]);\n\n  return Literal;\n}(Term); // ## BlankNode constructor\n\n\nvar BlankNode = /*#__PURE__*/function (_Term3) {\n  _inherits(BlankNode, _Term3);\n\n  function BlankNode(name) {\n    _classCallCheck(this, BlankNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlankNode).call(this, '_:' + name));\n  } // ### The term type of this term\n\n\n  _createClass(BlankNode, [{\n    key: \"termType\",\n    get: function get() {\n      return 'BlankNode';\n    } // ### The name of this blank node\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(2);\n    }\n  }]);\n\n  return BlankNode;\n}(Term);\n\nvar Variable = /*#__PURE__*/function (_Term4) {\n  _inherits(Variable, _Term4);\n\n  function Variable(name) {\n    _classCallCheck(this, Variable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Variable).call(this, '?' + name));\n  } // ### The term type of this term\n\n\n  _createClass(Variable, [{\n    key: \"termType\",\n    get: function get() {\n      return 'Variable';\n    } // ### The name of this variable\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(1);\n    }\n  }]);\n\n  return Variable;\n}(Term); // ## DefaultGraph constructor\n\n\nvar DefaultGraph = /*#__PURE__*/function (_Term5) {\n  _inherits(DefaultGraph, _Term5);\n\n  function DefaultGraph() {\n    var _this;\n\n    _classCallCheck(this, DefaultGraph);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultGraph).call(this, ''));\n    return _possibleConstructorReturn(_this, DEFAULTGRAPH || _assertThisInitialized(_assertThisInitialized(_this)));\n  } // ### The term type of this term\n\n\n  _createClass(DefaultGraph, [{\n    key: \"equals\",\n    // ### Returns whether this object represents the same term as the other\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through strict equality;\n      // otherwise, compare term types.\n      return this === other || !!other && this.termType === other.termType;\n    }\n  }, {\n    key: \"termType\",\n    get: function get() {\n      return 'DefaultGraph';\n    }\n  }]);\n\n  return DefaultGraph;\n}(Term); // ## DefaultGraph singleton\n\n\nDEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID\n\nfunction fromId(id, factory) {\n  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph\n\n  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character\n\n  switch (id[0]) {\n    case '_':\n      return factory.blankNode(id.substr(2));\n\n    case '?':\n      return factory.variable(id.substr(1));\n\n    case '\"':\n      // Shortcut for internal literals\n      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language\n\n      if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language\n\n      var endPos = id.lastIndexOf('\"', id.length - 1);\n      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n\n    default:\n      return factory.namedNode(id);\n  }\n} // ### Constructs an internal string ID from the given term or ID string\n\n\nfunction toId(term) {\n  if (typeof term === 'string') return term;\n  if (term instanceof Term) return term.id;\n  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n\n    case 'BlankNode':\n      return '_:' + term.value;\n\n    case 'Variable':\n      return '?' + term.value;\n\n    case 'DefaultGraph':\n      return '';\n\n    case 'Literal':\n      return '\"' + term.value + '\"' + (term.language ? '@' + term.language : term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : '');\n\n    default:\n      throw new Error('Unexpected termType: ' + term.termType);\n  }\n} // ## Quad constructor\n\n\nvar Quad = /*#__PURE__*/function () {\n  function Quad(subject, predicate, object, graph) {\n    _classCallCheck(this, Quad);\n\n    this.subject = subject;\n    this.predicate = predicate;\n    this.object = object;\n    this.graph = graph || DEFAULTGRAPH;\n  } // ### Returns a plain object representation of this quad\n\n\n  _createClass(Quad, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        subject: this.subject.toJSON(),\n        predicate: this.predicate.toJSON(),\n        object: this.object.toJSON(),\n        graph: this.graph.toJSON()\n      };\n    } // ### Returns whether this object represents the same quad as the other\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return !!other && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);\n    }\n  }]);\n\n  return Quad;\n}(); // ## DataFactory singleton\n\n\nDataFactory = {\n  // ### Public factory functions\n  namedNode: namedNode,\n  blankNode: blankNode,\n  variable: variable,\n  literal: literal,\n  defaultGraph: defaultGraph,\n  quad: quad,\n  triple: quad,\n  // ### Internal datatype constructors\n  internal: {\n    Term: Term,\n    NamedNode: NamedNode,\n    BlankNode: BlankNode,\n    Variable: Variable,\n    Literal: Literal,\n    DefaultGraph: DefaultGraph,\n    Quad: Quad,\n    Triple: Quad,\n    fromId: fromId,\n    toId: toId\n  }\n};\nexport default DataFactory; // ### Creates an IRI\n\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n} // ### Creates a blank node\n\n\nfunction blankNode(name) {\n  return new BlankNode(name || \"n3-\".concat(_blankNodeCounter++));\n} // ### Creates a literal\n\n\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string') return new Literal('\"' + value + '\"@' + languageOrDataType.toLowerCase()); // Automatically determine datatype for booleans and numbers\n\n  var datatype = languageOrDataType ? languageOrDataType.value : '';\n\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean') datatype = xsd.boolean; // Convert an integer or double\n    else if (typeof value === 'number') {\n        if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd.double;else {\n          datatype = xsd.double;\n          if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n        }\n      }\n  } // Create a datatyped literal\n\n\n  return datatype === '' || datatype === xsd.string ? new Literal('\"' + value + '\"') : new Literal('\"' + value + '\"^^' + datatype);\n} // ### Creates a variable\n\n\nfunction variable(name) {\n  return new Variable(name);\n} // ### Returns the default graph\n\n\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n} // ### Creates a quad\n\n\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}"],"sourceRoot":""}